// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_HONEYCRISP_SERIALIZED_H_
#define FLATBUFFERS_GENERATED_MODEL_HONEYCRISP_SERIALIZED_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace Honeycrisp {
namespace Serialized {

struct MeshMetaData;

struct Material;
struct MaterialBuilder;

struct Model;
struct ModelBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MeshMetaData FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t mesh_vertex_count_;
  uint32_t indices_buffer_count_;

 public:
  MeshMetaData()
      : mesh_vertex_count_(0),
        indices_buffer_count_(0) {
  }
  MeshMetaData(uint32_t _mesh_vertex_count, uint32_t _indices_buffer_count)
      : mesh_vertex_count_(::flatbuffers::EndianScalar(_mesh_vertex_count)),
        indices_buffer_count_(::flatbuffers::EndianScalar(_indices_buffer_count)) {
  }
  uint32_t mesh_vertex_count() const {
    return ::flatbuffers::EndianScalar(mesh_vertex_count_);
  }
  void mutate_mesh_vertex_count(uint32_t _mesh_vertex_count) {
    ::flatbuffers::WriteScalar(&mesh_vertex_count_, _mesh_vertex_count);
  }
  uint32_t indices_buffer_count() const {
    return ::flatbuffers::EndianScalar(indices_buffer_count_);
  }
  void mutate_indices_buffer_count(uint32_t _indices_buffer_count) {
    ::flatbuffers::WriteScalar(&indices_buffer_count_, _indices_buffer_count);
  }
};
FLATBUFFERS_STRUCT_END(MeshMetaData, 8);

struct Material FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALBEDO_PATH = 4,
    VT_ROUGHNESS_PATH = 6,
    VT_AO_PATH = 8,
    VT_NORMAL_PATH = 10,
    VT_SPECULAR_PATH = 12
  };
  const ::flatbuffers::String *albedo_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALBEDO_PATH);
  }
  ::flatbuffers::String *mutable_albedo_path() {
    return GetPointer<::flatbuffers::String *>(VT_ALBEDO_PATH);
  }
  const ::flatbuffers::String *roughness_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROUGHNESS_PATH);
  }
  ::flatbuffers::String *mutable_roughness_path() {
    return GetPointer<::flatbuffers::String *>(VT_ROUGHNESS_PATH);
  }
  const ::flatbuffers::String *ao_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AO_PATH);
  }
  ::flatbuffers::String *mutable_ao_path() {
    return GetPointer<::flatbuffers::String *>(VT_AO_PATH);
  }
  const ::flatbuffers::String *normal_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NORMAL_PATH);
  }
  ::flatbuffers::String *mutable_normal_path() {
    return GetPointer<::flatbuffers::String *>(VT_NORMAL_PATH);
  }
  const ::flatbuffers::String *specular_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPECULAR_PATH);
  }
  ::flatbuffers::String *mutable_specular_path() {
    return GetPointer<::flatbuffers::String *>(VT_SPECULAR_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALBEDO_PATH) &&
           verifier.VerifyString(albedo_path()) &&
           VerifyOffset(verifier, VT_ROUGHNESS_PATH) &&
           verifier.VerifyString(roughness_path()) &&
           VerifyOffset(verifier, VT_AO_PATH) &&
           verifier.VerifyString(ao_path()) &&
           VerifyOffset(verifier, VT_NORMAL_PATH) &&
           verifier.VerifyString(normal_path()) &&
           VerifyOffset(verifier, VT_SPECULAR_PATH) &&
           verifier.VerifyString(specular_path()) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  typedef Material Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_albedo_path(::flatbuffers::Offset<::flatbuffers::String> albedo_path) {
    fbb_.AddOffset(Material::VT_ALBEDO_PATH, albedo_path);
  }
  void add_roughness_path(::flatbuffers::Offset<::flatbuffers::String> roughness_path) {
    fbb_.AddOffset(Material::VT_ROUGHNESS_PATH, roughness_path);
  }
  void add_ao_path(::flatbuffers::Offset<::flatbuffers::String> ao_path) {
    fbb_.AddOffset(Material::VT_AO_PATH, ao_path);
  }
  void add_normal_path(::flatbuffers::Offset<::flatbuffers::String> normal_path) {
    fbb_.AddOffset(Material::VT_NORMAL_PATH, normal_path);
  }
  void add_specular_path(::flatbuffers::Offset<::flatbuffers::String> specular_path) {
    fbb_.AddOffset(Material::VT_SPECULAR_PATH, specular_path);
  }
  explicit MaterialBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Material> CreateMaterial(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> albedo_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> roughness_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ao_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> normal_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> specular_path = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_specular_path(specular_path);
  builder_.add_normal_path(normal_path);
  builder_.add_ao_path(ao_path);
  builder_.add_roughness_path(roughness_path);
  builder_.add_albedo_path(albedo_path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Material> CreateMaterialDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *albedo_path = nullptr,
    const char *roughness_path = nullptr,
    const char *ao_path = nullptr,
    const char *normal_path = nullptr,
    const char *specular_path = nullptr) {
  auto albedo_path__ = albedo_path ? _fbb.CreateString(albedo_path) : 0;
  auto roughness_path__ = roughness_path ? _fbb.CreateString(roughness_path) : 0;
  auto ao_path__ = ao_path ? _fbb.CreateString(ao_path) : 0;
  auto normal_path__ = normal_path ? _fbb.CreateString(normal_path) : 0;
  auto specular_path__ = specular_path ? _fbb.CreateString(specular_path) : 0;
  return Honeycrisp::Serialized::CreateMaterial(
      _fbb,
      albedo_path__,
      roughness_path__,
      ao_path__,
      normal_path__,
      specular_path__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTEX_ATTRIB_BITS = 4,
    VT_VERTEX_DATA = 6,
    VT_INDICES = 8,
    VT_MESHES = 10,
    VT_MATERIAL = 12,
    VT_LAST_WRITE_TIME = 14
  };
  uint16_t vertex_attrib_bits() const {
    return GetField<uint16_t>(VT_VERTEX_ATTRIB_BITS, 0);
  }
  bool mutate_vertex_attrib_bits(uint16_t _vertex_attrib_bits = 0) {
    return SetField<uint16_t>(VT_VERTEX_ATTRIB_BITS, _vertex_attrib_bits, 0);
  }
  const ::flatbuffers::Vector<float> *vertex_data() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VERTEX_DATA);
  }
  ::flatbuffers::Vector<float> *mutable_vertex_data() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_VERTEX_DATA);
  }
  const ::flatbuffers::Vector<uint32_t> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_indices() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  const ::flatbuffers::Vector<const Honeycrisp::Serialized::MeshMetaData *> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<const Honeycrisp::Serialized::MeshMetaData *> *>(VT_MESHES);
  }
  ::flatbuffers::Vector<const Honeycrisp::Serialized::MeshMetaData *> *mutable_meshes() {
    return GetPointer<::flatbuffers::Vector<const Honeycrisp::Serialized::MeshMetaData *> *>(VT_MESHES);
  }
  const Honeycrisp::Serialized::Material *material() const {
    return GetPointer<const Honeycrisp::Serialized::Material *>(VT_MATERIAL);
  }
  Honeycrisp::Serialized::Material *mutable_material() {
    return GetPointer<Honeycrisp::Serialized::Material *>(VT_MATERIAL);
  }
  int64_t last_write_time() const {
    return GetField<int64_t>(VT_LAST_WRITE_TIME, 0);
  }
  bool mutate_last_write_time(int64_t _last_write_time = 0) {
    return SetField<int64_t>(VT_LAST_WRITE_TIME, _last_write_time, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VERTEX_ATTRIB_BITS, 2) &&
           VerifyOffset(verifier, VT_VERTEX_DATA) &&
           verifier.VerifyVector(vertex_data()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           VerifyField<int64_t>(verifier, VT_LAST_WRITE_TIME, 8) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vertex_attrib_bits(uint16_t vertex_attrib_bits) {
    fbb_.AddElement<uint16_t>(Model::VT_VERTEX_ATTRIB_BITS, vertex_attrib_bits, 0);
  }
  void add_vertex_data(::flatbuffers::Offset<::flatbuffers::Vector<float>> vertex_data) {
    fbb_.AddOffset(Model::VT_VERTEX_DATA, vertex_data);
  }
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> indices) {
    fbb_.AddOffset(Model::VT_INDICES, indices);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<const Honeycrisp::Serialized::MeshMetaData *>> meshes) {
    fbb_.AddOffset(Model::VT_MESHES, meshes);
  }
  void add_material(::flatbuffers::Offset<Honeycrisp::Serialized::Material> material) {
    fbb_.AddOffset(Model::VT_MATERIAL, material);
  }
  void add_last_write_time(int64_t last_write_time) {
    fbb_.AddElement<int64_t>(Model::VT_LAST_WRITE_TIME, last_write_time, 0);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t vertex_attrib_bits = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> vertex_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Honeycrisp::Serialized::MeshMetaData *>> meshes = 0,
    ::flatbuffers::Offset<Honeycrisp::Serialized::Material> material = 0,
    int64_t last_write_time = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_last_write_time(last_write_time);
  builder_.add_material(material);
  builder_.add_meshes(meshes);
  builder_.add_indices(indices);
  builder_.add_vertex_data(vertex_data);
  builder_.add_vertex_attrib_bits(vertex_attrib_bits);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t vertex_attrib_bits = 0,
    const std::vector<float> *vertex_data = nullptr,
    const std::vector<uint32_t> *indices = nullptr,
    const std::vector<Honeycrisp::Serialized::MeshMetaData> *meshes = nullptr,
    ::flatbuffers::Offset<Honeycrisp::Serialized::Material> material = 0,
    int64_t last_write_time = 0) {
  auto vertex_data__ = vertex_data ? _fbb.CreateVector<float>(*vertex_data) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint32_t>(*indices) : 0;
  auto meshes__ = meshes ? _fbb.CreateVectorOfStructs<Honeycrisp::Serialized::MeshMetaData>(*meshes) : 0;
  return Honeycrisp::Serialized::CreateModel(
      _fbb,
      vertex_attrib_bits,
      vertex_data__,
      indices__,
      meshes__,
      material,
      last_write_time);
}

inline const Honeycrisp::Serialized::Model *GetModel(const void *buf) {
  return ::flatbuffers::GetRoot<Honeycrisp::Serialized::Model>(buf);
}

inline const Honeycrisp::Serialized::Model *GetSizePrefixedModel(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Honeycrisp::Serialized::Model>(buf);
}

inline Model *GetMutableModel(void *buf) {
  return ::flatbuffers::GetMutableRoot<Model>(buf);
}

inline Honeycrisp::Serialized::Model *GetMutableSizePrefixedModel(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Honeycrisp::Serialized::Model>(buf);
}

inline bool VerifyModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Honeycrisp::Serialized::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Honeycrisp::Serialized::Model>(nullptr);
}

inline void FinishModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Honeycrisp::Serialized::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Honeycrisp::Serialized::Model> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Serialized
}  // namespace Honeycrisp

#endif  // FLATBUFFERS_GENERATED_MODEL_HONEYCRISP_SERIALIZED_H_
